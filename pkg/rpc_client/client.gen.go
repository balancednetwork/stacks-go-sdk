// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package rpc_client

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// GetAccountInfoParams defines parameters for GetAccountInfo.
type GetAccountInfoParams struct {
	// Proof Returns object without the proof field if set to 0
	Proof *int `form:"proof,omitempty" json:"proof,omitempty"`

	// Tip The Stacks chain tip to query from. If tip == latest, the query will be run from the latest known tip (includes unconfirmed state).
	Tip *string `form:"tip,omitempty" json:"tip,omitempty"`
}

// PostBlockProposalJSONBody defines parameters for PostBlockProposal.
type PostBlockProposalJSONBody interface{}

// GetConstantValParams defines parameters for GetConstantVal.
type GetConstantValParams struct {
	// Tip The Stacks chain tip to query from. If tip == latest, the query will be run from the latest known tip (includes unconfirmed state).
	Tip *string `form:"tip,omitempty" json:"tip,omitempty"`
}

// CallReadOnlyFunctionJSONBody defines parameters for CallReadOnlyFunction.
type CallReadOnlyFunctionJSONBody struct {
	// Arguments An array of hex serialized Clarity values
	Arguments []string `json:"arguments"`

	// Sender The simulated tx-sender
	Sender string `json:"sender"`
}

// CallReadOnlyFunctionParams defines parameters for CallReadOnlyFunction.
type CallReadOnlyFunctionParams struct {
	// Tip The Stacks chain tip to query from. If tip == latest, the query will be run from the latest known tip (includes unconfirmed state).
	Tip *string `form:"tip,omitempty" json:"tip,omitempty"`
}

// GetContractInterfaceParams defines parameters for GetContractInterface.
type GetContractInterfaceParams struct {
	// Tip The Stacks chain tip to query from. If tip == latest, the query will be run from the latest known tip (includes unconfirmed state).
	Tip *string `form:"tip,omitempty" json:"tip,omitempty"`
}

// GetContractSourceParams defines parameters for GetContractSource.
type GetContractSourceParams struct {
	// Proof Returns object without the proof field if set to 0
	Proof *int `form:"proof,omitempty" json:"proof,omitempty"`

	// Tip The Stacks chain tip to query from. If tip == latest, the query will be run from the latest known tip (includes unconfirmed state).
	Tip *string `form:"tip,omitempty" json:"tip,omitempty"`
}

// PostFeeTransactionJSONBody defines parameters for PostFeeTransaction.
type PostFeeTransactionJSONBody struct {
	EstimatedLen       *int   `json:"estimated_len,omitempty"`
	TransactionPayload string `json:"transaction_payload"`
}

// GetContractDataMapEntryJSONBody defines parameters for GetContractDataMapEntry.
type GetContractDataMapEntryJSONBody = string

// GetContractDataMapEntryParams defines parameters for GetContractDataMapEntry.
type GetContractDataMapEntryParams struct {
	// Proof Returns object without the proof field when set to 0
	Proof *int `form:"proof,omitempty" json:"proof,omitempty"`

	// Tip The Stacks chain tip to query from. If tip == latest, the query will be run from the latest known tip (includes unconfirmed state).
	Tip *string `form:"tip,omitempty" json:"tip,omitempty"`
}

// GetPoxInfoParams defines parameters for GetPoxInfo.
type GetPoxInfoParams struct {
	// Tip The Stacks chain tip to query from. If tip == latest, the query will be run from the latest known tip (includes unconfirmed state).
	Tip *string `form:"tip,omitempty" json:"tip,omitempty"`
}

// GetIsTraitImplementedParams defines parameters for GetIsTraitImplemented.
type GetIsTraitImplementedParams struct {
	// Tip The Stacks chain tip to query from.
	// If tip == "latest", the query will be run from the latest known tip (includes unconfirmed state).
	// If the tip is left unspecified, the stacks chain tip will be selected (only includes confirmed state).
	Tip *string `form:"tip,omitempty" json:"tip,omitempty"`
}

// GetTenuresParams defines parameters for GetTenures.
type GetTenuresParams struct {
	// Stop The block ID hash of the highest block in this tenure that is already known to the caller.  Neither the corresponding block nor any of its ancestors will be served.  This is used to fetch tenure blocks that the caller does not have.
	Stop *string `form:"stop,omitempty" json:"stop,omitempty"`
}

// PostBlockProposalJSONRequestBody defines body for PostBlockProposal for application/json ContentType.
type PostBlockProposalJSONRequestBody PostBlockProposalJSONBody

// CallReadOnlyFunctionJSONRequestBody defines body for CallReadOnlyFunction for application/json ContentType.
type CallReadOnlyFunctionJSONRequestBody CallReadOnlyFunctionJSONBody

// PostFeeTransactionJSONRequestBody defines body for PostFeeTransaction for application/json ContentType.
type PostFeeTransactionJSONRequestBody PostFeeTransactionJSONBody

// GetContractDataMapEntryJSONRequestBody defines body for GetContractDataMapEntry for application/json ContentType.
type GetContractDataMapEntryJSONRequestBody = GetContractDataMapEntryJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAccountInfo request
	GetAccountInfo(ctx context.Context, principal string, params *GetAccountInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostBlockProposalWithBody request with any body
	PostBlockProposalWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostBlockProposal(ctx context.Context, body PostBlockProposalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBurnOps request
	GetBurnOps(ctx context.Context, burnHeight int, opType string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConstantVal request
	GetConstantVal(ctx context.Context, contractAddress string, contractName string, constantName string, params *GetConstantValParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CallReadOnlyFunctionWithBody request with any body
	CallReadOnlyFunctionWithBody(ctx context.Context, contractAddress string, contractName string, functionName string, params *CallReadOnlyFunctionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CallReadOnlyFunction(ctx context.Context, contractAddress string, contractName string, functionName string, params *CallReadOnlyFunctionParams, body CallReadOnlyFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContractInterface request
	GetContractInterface(ctx context.Context, contractAddress string, contractName string, params *GetContractInterfaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContractSource request
	GetContractSource(ctx context.Context, contractAddress string, contractName string, params *GetContractSourceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFeeTransactionWithBody request with any body
	PostFeeTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFeeTransaction(ctx context.Context, body PostFeeTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFeeTransfer request
	GetFeeTransfer(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCoreApiInfo request
	GetCoreApiInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContractDataMapEntryWithBody request with any body
	GetContractDataMapEntryWithBody(ctx context.Context, contractAddress string, contractName string, mapName string, params *GetContractDataMapEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetContractDataMapEntry(ctx context.Context, contractAddress string, contractName string, mapName string, params *GetContractDataMapEntryParams, body GetContractDataMapEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPoxInfo request
	GetPoxInfo(ctx context.Context, params *GetPoxInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStackerSet request
	GetStackerSet(ctx context.Context, cycleNumber int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIsTraitImplemented request
	GetIsTraitImplemented(ctx context.Context, contractAddress string, contractName string, traitContractAddress string, traitContractName string, traitName string, params *GetIsTraitImplementedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCoreNodeTransactionsWithBody request with any body
	PostCoreNodeTransactionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlockV3 request
	GetBlockV3(ctx context.Context, blockId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTenureInfo request
	GetTenureInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTenures request
	GetTenures(ctx context.Context, blockId string, params *GetTenuresParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAccountInfo(ctx context.Context, principal string, params *GetAccountInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountInfoRequest(c.Server, principal, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBlockProposalWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBlockProposalRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBlockProposal(ctx context.Context, body PostBlockProposalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBlockProposalRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBurnOps(ctx context.Context, burnHeight int, opType string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBurnOpsRequest(c.Server, burnHeight, opType)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConstantVal(ctx context.Context, contractAddress string, contractName string, constantName string, params *GetConstantValParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConstantValRequest(c.Server, contractAddress, contractName, constantName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CallReadOnlyFunctionWithBody(ctx context.Context, contractAddress string, contractName string, functionName string, params *CallReadOnlyFunctionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCallReadOnlyFunctionRequestWithBody(c.Server, contractAddress, contractName, functionName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CallReadOnlyFunction(ctx context.Context, contractAddress string, contractName string, functionName string, params *CallReadOnlyFunctionParams, body CallReadOnlyFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCallReadOnlyFunctionRequest(c.Server, contractAddress, contractName, functionName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContractInterface(ctx context.Context, contractAddress string, contractName string, params *GetContractInterfaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContractInterfaceRequest(c.Server, contractAddress, contractName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContractSource(ctx context.Context, contractAddress string, contractName string, params *GetContractSourceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContractSourceRequest(c.Server, contractAddress, contractName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFeeTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFeeTransactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFeeTransaction(ctx context.Context, body PostFeeTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFeeTransactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFeeTransfer(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFeeTransferRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCoreApiInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCoreApiInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContractDataMapEntryWithBody(ctx context.Context, contractAddress string, contractName string, mapName string, params *GetContractDataMapEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContractDataMapEntryRequestWithBody(c.Server, contractAddress, contractName, mapName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContractDataMapEntry(ctx context.Context, contractAddress string, contractName string, mapName string, params *GetContractDataMapEntryParams, body GetContractDataMapEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContractDataMapEntryRequest(c.Server, contractAddress, contractName, mapName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPoxInfo(ctx context.Context, params *GetPoxInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPoxInfoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStackerSet(ctx context.Context, cycleNumber int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStackerSetRequest(c.Server, cycleNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIsTraitImplemented(ctx context.Context, contractAddress string, contractName string, traitContractAddress string, traitContractName string, traitName string, params *GetIsTraitImplementedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIsTraitImplementedRequest(c.Server, contractAddress, contractName, traitContractAddress, traitContractName, traitName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCoreNodeTransactionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCoreNodeTransactionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlockV3(ctx context.Context, blockId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlockV3Request(c.Server, blockId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTenureInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTenureInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTenures(ctx context.Context, blockId string, params *GetTenuresParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTenuresRequest(c.Server, blockId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAccountInfoRequest generates requests for GetAccountInfo
func NewGetAccountInfoRequest(server string, principal string, params *GetAccountInfoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "principal", runtime.ParamLocationPath, principal)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Proof != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "proof", runtime.ParamLocationQuery, *params.Proof); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tip", runtime.ParamLocationQuery, *params.Tip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostBlockProposalRequest calls the generic PostBlockProposal builder with application/json body
func NewPostBlockProposalRequest(server string, body PostBlockProposalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostBlockProposalRequestWithBody(server, "application/json", bodyReader)
}

// NewPostBlockProposalRequestWithBody generates requests for PostBlockProposal with any type of body
func NewPostBlockProposalRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/block_proposal")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBurnOpsRequest generates requests for GetBurnOps
func NewGetBurnOpsRequest(server string, burnHeight int, opType string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "burn_height", runtime.ParamLocationPath, burnHeight)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "op_type", runtime.ParamLocationPath, opType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/burn_ops/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConstantValRequest generates requests for GetConstantVal
func NewGetConstantValRequest(server string, contractAddress string, contractName string, constantName string, params *GetConstantValParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "contract_address", runtime.ParamLocationPath, contractAddress)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "contract_name", runtime.ParamLocationPath, contractName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "constant_name", runtime.ParamLocationPath, constantName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/constant_val/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tip", runtime.ParamLocationQuery, *params.Tip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCallReadOnlyFunctionRequest calls the generic CallReadOnlyFunction builder with application/json body
func NewCallReadOnlyFunctionRequest(server string, contractAddress string, contractName string, functionName string, params *CallReadOnlyFunctionParams, body CallReadOnlyFunctionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCallReadOnlyFunctionRequestWithBody(server, contractAddress, contractName, functionName, params, "application/json", bodyReader)
}

// NewCallReadOnlyFunctionRequestWithBody generates requests for CallReadOnlyFunction with any type of body
func NewCallReadOnlyFunctionRequestWithBody(server string, contractAddress string, contractName string, functionName string, params *CallReadOnlyFunctionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "contract_address", runtime.ParamLocationPath, contractAddress)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "contract_name", runtime.ParamLocationPath, contractName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "function_name", runtime.ParamLocationPath, functionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/contracts/call-read/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tip", runtime.ParamLocationQuery, *params.Tip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetContractInterfaceRequest generates requests for GetContractInterface
func NewGetContractInterfaceRequest(server string, contractAddress string, contractName string, params *GetContractInterfaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "contract_address", runtime.ParamLocationPath, contractAddress)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "contract_name", runtime.ParamLocationPath, contractName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/contracts/interface/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tip", runtime.ParamLocationQuery, *params.Tip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContractSourceRequest generates requests for GetContractSource
func NewGetContractSourceRequest(server string, contractAddress string, contractName string, params *GetContractSourceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "contract_address", runtime.ParamLocationPath, contractAddress)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "contract_name", runtime.ParamLocationPath, contractName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/contracts/source/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Proof != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "proof", runtime.ParamLocationQuery, *params.Proof); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tip", runtime.ParamLocationQuery, *params.Tip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostFeeTransactionRequest calls the generic PostFeeTransaction builder with application/json body
func NewPostFeeTransactionRequest(server string, body PostFeeTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFeeTransactionRequestWithBody(server, "application/json", bodyReader)
}

// NewPostFeeTransactionRequestWithBody generates requests for PostFeeTransaction with any type of body
func NewPostFeeTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/fees/transaction")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFeeTransferRequest generates requests for GetFeeTransfer
func NewGetFeeTransferRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/fees/transfer")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCoreApiInfoRequest generates requests for GetCoreApiInfo
func NewGetCoreApiInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContractDataMapEntryRequest calls the generic GetContractDataMapEntry builder with application/json body
func NewGetContractDataMapEntryRequest(server string, contractAddress string, contractName string, mapName string, params *GetContractDataMapEntryParams, body GetContractDataMapEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetContractDataMapEntryRequestWithBody(server, contractAddress, contractName, mapName, params, "application/json", bodyReader)
}

// NewGetContractDataMapEntryRequestWithBody generates requests for GetContractDataMapEntry with any type of body
func NewGetContractDataMapEntryRequestWithBody(server string, contractAddress string, contractName string, mapName string, params *GetContractDataMapEntryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "contract_address", runtime.ParamLocationPath, contractAddress)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "contract_name", runtime.ParamLocationPath, contractName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "map_name", runtime.ParamLocationPath, mapName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/map_entry/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Proof != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "proof", runtime.ParamLocationQuery, *params.Proof); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tip", runtime.ParamLocationQuery, *params.Tip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPoxInfoRequest generates requests for GetPoxInfo
func NewGetPoxInfoRequest(server string, params *GetPoxInfoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/pox")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tip", runtime.ParamLocationQuery, *params.Tip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStackerSetRequest generates requests for GetStackerSet
func NewGetStackerSetRequest(server string, cycleNumber int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cycle_number", runtime.ParamLocationPath, cycleNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/stacker_set/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIsTraitImplementedRequest generates requests for GetIsTraitImplemented
func NewGetIsTraitImplementedRequest(server string, contractAddress string, contractName string, traitContractAddress string, traitContractName string, traitName string, params *GetIsTraitImplementedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "contract_address", runtime.ParamLocationPath, contractAddress)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "contract_name", runtime.ParamLocationPath, contractName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "trait_contract_address", runtime.ParamLocationPath, traitContractAddress)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "trait_contract_name", runtime.ParamLocationPath, traitContractName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "trait_name", runtime.ParamLocationPath, traitName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/traits/%s/%s/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tip", runtime.ParamLocationQuery, *params.Tip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCoreNodeTransactionsRequestWithBody generates requests for PostCoreNodeTransactions with any type of body
func NewPostCoreNodeTransactionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBlockV3Request generates requests for GetBlockV3
func NewGetBlockV3Request(server string, blockId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "block_id", runtime.ParamLocationPath, blockId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/blocks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTenureInfoRequest generates requests for GetTenureInfo
func NewGetTenureInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/tenures/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTenuresRequest generates requests for GetTenures
func NewGetTenuresRequest(server string, blockId string, params *GetTenuresParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "block_id", runtime.ParamLocationPath, blockId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/tenures/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Stop != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stop", runtime.ParamLocationQuery, *params.Stop); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAccountInfoWithResponse request
	GetAccountInfoWithResponse(ctx context.Context, principal string, params *GetAccountInfoParams, reqEditors ...RequestEditorFn) (*GetAccountInfoResponse, error)

	// PostBlockProposalWithBodyWithResponse request with any body
	PostBlockProposalWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBlockProposalResponse, error)

	PostBlockProposalWithResponse(ctx context.Context, body PostBlockProposalJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBlockProposalResponse, error)

	// GetBurnOpsWithResponse request
	GetBurnOpsWithResponse(ctx context.Context, burnHeight int, opType string, reqEditors ...RequestEditorFn) (*GetBurnOpsResponse, error)

	// GetConstantValWithResponse request
	GetConstantValWithResponse(ctx context.Context, contractAddress string, contractName string, constantName string, params *GetConstantValParams, reqEditors ...RequestEditorFn) (*GetConstantValResponse, error)

	// CallReadOnlyFunctionWithBodyWithResponse request with any body
	CallReadOnlyFunctionWithBodyWithResponse(ctx context.Context, contractAddress string, contractName string, functionName string, params *CallReadOnlyFunctionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CallReadOnlyFunctionResponse, error)

	CallReadOnlyFunctionWithResponse(ctx context.Context, contractAddress string, contractName string, functionName string, params *CallReadOnlyFunctionParams, body CallReadOnlyFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*CallReadOnlyFunctionResponse, error)

	// GetContractInterfaceWithResponse request
	GetContractInterfaceWithResponse(ctx context.Context, contractAddress string, contractName string, params *GetContractInterfaceParams, reqEditors ...RequestEditorFn) (*GetContractInterfaceResponse, error)

	// GetContractSourceWithResponse request
	GetContractSourceWithResponse(ctx context.Context, contractAddress string, contractName string, params *GetContractSourceParams, reqEditors ...RequestEditorFn) (*GetContractSourceResponse, error)

	// PostFeeTransactionWithBodyWithResponse request with any body
	PostFeeTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFeeTransactionResponse, error)

	PostFeeTransactionWithResponse(ctx context.Context, body PostFeeTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFeeTransactionResponse, error)

	// GetFeeTransferWithResponse request
	GetFeeTransferWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFeeTransferResponse, error)

	// GetCoreApiInfoWithResponse request
	GetCoreApiInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCoreApiInfoResponse, error)

	// GetContractDataMapEntryWithBodyWithResponse request with any body
	GetContractDataMapEntryWithBodyWithResponse(ctx context.Context, contractAddress string, contractName string, mapName string, params *GetContractDataMapEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetContractDataMapEntryResponse, error)

	GetContractDataMapEntryWithResponse(ctx context.Context, contractAddress string, contractName string, mapName string, params *GetContractDataMapEntryParams, body GetContractDataMapEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*GetContractDataMapEntryResponse, error)

	// GetPoxInfoWithResponse request
	GetPoxInfoWithResponse(ctx context.Context, params *GetPoxInfoParams, reqEditors ...RequestEditorFn) (*GetPoxInfoResponse, error)

	// GetStackerSetWithResponse request
	GetStackerSetWithResponse(ctx context.Context, cycleNumber int, reqEditors ...RequestEditorFn) (*GetStackerSetResponse, error)

	// GetIsTraitImplementedWithResponse request
	GetIsTraitImplementedWithResponse(ctx context.Context, contractAddress string, contractName string, traitContractAddress string, traitContractName string, traitName string, params *GetIsTraitImplementedParams, reqEditors ...RequestEditorFn) (*GetIsTraitImplementedResponse, error)

	// PostCoreNodeTransactionsWithBodyWithResponse request with any body
	PostCoreNodeTransactionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCoreNodeTransactionsResponse, error)

	// GetBlockV3WithResponse request
	GetBlockV3WithResponse(ctx context.Context, blockId string, reqEditors ...RequestEditorFn) (*GetBlockV3Response, error)

	// GetTenureInfoWithResponse request
	GetTenureInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTenureInfoResponse, error)

	// GetTenuresWithResponse request
	GetTenuresWithResponse(ctx context.Context, blockId string, params *GetTenuresParams, reqEditors ...RequestEditorFn) (*GetTenuresResponse, error)
}

type GetAccountInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Balance      string `json:"balance"`
		BalanceProof string `json:"balance_proof"`
		Locked       string `json:"locked"`
		Nonce        int    `json:"nonce"`
		NonceProof   string `json:"nonce_proof"`
		UnlockHeight int    `json:"unlock_height"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAccountInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostBlockProposalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostBlockProposalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostBlockProposalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBurnOpsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetBurnOpsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBurnOpsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConstantValResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Hex-encoded string of clarity value.
		Data string `json:"data"`
	}
}

// Status returns HTTPResponse.Status
func (r GetConstantValResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConstantValResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CallReadOnlyFunctionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Cause  *string `json:"cause,omitempty"`
		Okay   bool    `json:"okay"`
		Result *string `json:"result,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CallReadOnlyFunctionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CallReadOnlyFunctionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContractInterfaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Functions List of defined methods
		Functions []map[string]interface{} `json:"functions"`

		// FungibleTokens List of fungible tokens in the contract
		FungibleTokens []map[string]interface{} `json:"fungible_tokens"`

		// Maps List of defined data-maps
		Maps []map[string]interface{} `json:"maps"`

		// NonFungibleTokens List of non-fungible tokens in the contract
		NonFungibleTokens []map[string]interface{} `json:"non_fungible_tokens"`

		// Variables List of defined variables
		Variables []map[string]interface{} `json:"variables"`
	}
}

// Status returns HTTPResponse.Status
func (r GetContractInterfaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContractInterfaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContractSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Proof         string `json:"proof"`
		PublishHeight int    `json:"publish_height"`
		Source        string `json:"source"`
	}
}

// Status returns HTTPResponse.Status
func (r GetContractSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContractSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFeeTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CostScalarChangeByByte *float32 `json:"cost_scalar_change_by_byte,omitempty"`
		EstimatedCost          struct {
			ReadCount   int `json:"read_count"`
			ReadLength  int `json:"read_length"`
			Runtime     int `json:"runtime"`
			WriteCount  int `json:"write_count"`
			WriteLength int `json:"write_length"`
		} `json:"estimated_cost"`
		EstimatedCostScalar int `json:"estimated_cost_scalar"`
		Estimations         *[]struct {
			Fee     *float32 `json:"fee,omitempty"`
			FeeRate *float32 `json:"fee_rate,omitempty"`
		} `json:"estimations,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostFeeTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFeeTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFeeTransferResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetFeeTransferResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFeeTransferResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCoreApiInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// BurnBlockHeight latest bitcoin chain height
		BurnBlockHeight int `json:"burn_block_height"`

		// ExitAtBlockHeight the block height at which the testnet network will be reset. not applicable for mainnet
		ExitAtBlockHeight int `json:"exit_at_block_height"`

		// NetworkId is similar to peer_version and will be used to differentiate between different testnets. this value will be different between mainnet and testnet. once launched, this value will not change
		NetworkId int `json:"network_id"`

		// ParentNetworkId same as network_id, but for bitcoin
		ParentNetworkId int `json:"parent_network_id"`

		// PeerVersion identifies the version number for the networking communication, this should not change while a node is running, and will only change if there's an upgrade
		PeerVersion int `json:"peer_version"`

		// PoxConsensus is a hash used to identify the burnchain view for a node. it incorporates bitcoin chain information and PoX information. nodes that disagree on this value will appear to each other as forks. this value will change after every block
		PoxConsensus string `json:"pox_consensus"`

		// ServerVersion is a version descriptor
		ServerVersion string `json:"server_version"`

		// StableBurnBlockHeight leftover from stacks 1.0, basically always burn_block_height - 1
		StableBurnBlockHeight int `json:"stable_burn_block_height"`

		// StablePoxConsensus same as burn_consensus, but evaluated at stable_burn_block_height
		StablePoxConsensus string `json:"stable_pox_consensus"`

		// StacksTip the best known block hash for the Stack chain (not including any pending microblocks)
		StacksTip string `json:"stacks_tip"`

		// StacksTipConsensusHash the burn chain (i.e., bitcoin) consensus hash at the time that stacks_tip was mined
		StacksTipConsensusHash string `json:"stacks_tip_consensus_hash"`

		// StacksTipHeight the latest Stacks chain height. Stacks forks can occur independent of the Bitcoin chain, that height doesn't increase 1-to-1 with the Bitcoin height
		StacksTipHeight int `json:"stacks_tip_height"`

		// UnanchoredTip the latest microblock hash if any microblocks were processed. if no microblock has been processed for the current block, a 000.., hex array is returned
		UnanchoredTip string `json:"unanchored_tip"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCoreApiInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCoreApiInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContractDataMapEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Hex-encoded string of clarity value. It is always an optional tuple.
		Data string `json:"data"`

		// Proof Hex-encoded string of the MARF proof for the data
		Proof *string `json:"proof,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetContractDataMapEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContractDataMapEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPoxInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ContractId The contract identifier for the PoX contract
		ContractId string `json:"contract_id"`

		// ContractVersions Versions of each PoX
		ContractVersions []struct {
			// ActivationBurnchainBlockHeight The burn block height at which this version of PoX is activated
			ActivationBurnchainBlockHeight int `json:"activation_burnchain_block_height"`

			// ContractId The contract identifier for the PoX contract
			ContractId string `json:"contract_id"`

			// FirstRewardCycleId The first reward cycle number that uses this version of PoX
			FirstRewardCycleId int `json:"first_reward_cycle_id"`
		} `json:"contract_versions"`

		// CurrentBurnchainBlockHeight The latest Bitcoin chain block height
		CurrentBurnchainBlockHeight int `json:"current_burnchain_block_height"`
		CurrentCycle                struct {
			// Id The reward cycle number
			Id int `json:"id"`

			// IsPoxActive Whether or not PoX is active during this reward cycle.
			IsPoxActive bool `json:"is_pox_active"`

			// MinThresholdUstx The threshold amount for obtaining a slot in this reward cycle.
			MinThresholdUstx int `json:"min_threshold_ustx"`

			// StackedUstx The total amount of stacked microstacks in this reward cycle.
			StackedUstx int `json:"stacked_ustx"`
		} `json:"current_cycle"`

		// FirstBurnchainBlockHeight The first burn block evaluated in this Stacks chain
		FirstBurnchainBlockHeight int `json:"first_burnchain_block_height"`
		// Deprecated:
		MinAmountUstx int `json:"min_amount_ustx"`
		NextCycle     struct {
			// BlocksUntilPreparePhase The number of burn blocks until the prepare phase for this cycle starts. If the prepare phase for this cycle already started, this value will be negative.
			BlocksUntilPreparePhase int `json:"blocks_until_prepare_phase"`

			// BlocksUntilRewardPhase The number of burn blocks until this reward phase starts.
			BlocksUntilRewardPhase int `json:"blocks_until_reward_phase"`

			// Id The reward cycle number
			Id int `json:"id"`

			// MinIncrementUstx The minimum amount that can be used to submit a `stack-stx` call.
			MinIncrementUstx int `json:"min_increment_ustx"`

			// MinThresholdUstx The threshold amount for obtaining a slot in this reward cycle.
			MinThresholdUstx int `json:"min_threshold_ustx"`

			// PreparePhaseStartBlockHeight The burn block height when the prepare phase for this cycle begins. Any eligible stacks must be stacked before this block.
			PreparePhaseStartBlockHeight int `json:"prepare_phase_start_block_height"`

			// RewardPhaseStartBlockHeight The burn block height when the reward phase for this cycle begins. Any eligible stacks must be stacked before this block.
			RewardPhaseStartBlockHeight int `json:"reward_phase_start_block_height"`

			// StackedUstx The total amount of stacked microstacks in this reward cycle.
			StackedUstx int `json:"stacked_ustx"`

			// UstxUntilPoxRejection The remaining amount of liquid STX that must vote to reject the next reward cycle to prevent the next reward cycle from activating.
			UstxUntilPoxRejection int `json:"ustx_until_pox_rejection"`
		} `json:"next_cycle"`

		// PoxActivationThresholdUstx The threshold of stacking participation that must be reached for PoX to activate in any cycle
		PoxActivationThresholdUstx int `json:"pox_activation_threshold_ustx"`
		// Deprecated:
		PrepareCycleLength int `json:"prepare_cycle_length"`

		// PreparePhaseBlockLength The length in burn blocks of the prepare phase
		PreparePhaseBlockLength int `json:"prepare_phase_block_length"`

		// RejectionFraction The fraction of liquid STX that must vote to reject PoX in order to prevent the next reward cycle from activating.
		RejectionFraction int `json:"rejection_fraction"`
		// Deprecated:
		RejectionVotesLeftRequired int `json:"rejection_votes_left_required"`

		// RewardCycleId The active reward cycle number
		// Deprecated:
		RewardCycleId int `json:"reward_cycle_id"`

		// RewardCycleLength The length in burn blocks of a whole PoX cycle (reward phase and prepare phase)
		RewardCycleLength int `json:"reward_cycle_length"`

		// RewardPhaseBlockLength The length in burn blocks of the reward phase
		RewardPhaseBlockLength int `json:"reward_phase_block_length"`

		// RewardSlots The number of reward slots in a reward cycle
		RewardSlots int `json:"reward_slots"`

		// TotalLiquidSupplyUstx The current total amount of liquid microstacks.
		TotalLiquidSupplyUstx int `json:"total_liquid_supply_ustx"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPoxInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPoxInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStackerSetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetStackerSetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStackerSetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIsTraitImplementedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsImplemented bool `json:"is_implemented"`
	}
}

// Status returns HTTPResponse.Status
func (r GetIsTraitImplementedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIsTraitImplementedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCoreNodeTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		// Error The error
		Error string `json:"error"`

		// Reason The reason for the error
		Reason string `json:"reason"`

		// ReasonData More details about the reason
		ReasonData map[string]interface{} `json:"reason_data"`

		// Txid The relevant transaction id
		Txid string `json:"txid"`
	}
}

// Status returns HTTPResponse.Status
func (r PostCoreNodeTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCoreNodeTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlockV3Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetBlockV3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockV3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTenureInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetTenureInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTenureInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTenuresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetTenuresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTenuresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAccountInfoWithResponse request returning *GetAccountInfoResponse
func (c *ClientWithResponses) GetAccountInfoWithResponse(ctx context.Context, principal string, params *GetAccountInfoParams, reqEditors ...RequestEditorFn) (*GetAccountInfoResponse, error) {
	rsp, err := c.GetAccountInfo(ctx, principal, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountInfoResponse(rsp)
}

// PostBlockProposalWithBodyWithResponse request with arbitrary body returning *PostBlockProposalResponse
func (c *ClientWithResponses) PostBlockProposalWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBlockProposalResponse, error) {
	rsp, err := c.PostBlockProposalWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBlockProposalResponse(rsp)
}

func (c *ClientWithResponses) PostBlockProposalWithResponse(ctx context.Context, body PostBlockProposalJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBlockProposalResponse, error) {
	rsp, err := c.PostBlockProposal(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBlockProposalResponse(rsp)
}

// GetBurnOpsWithResponse request returning *GetBurnOpsResponse
func (c *ClientWithResponses) GetBurnOpsWithResponse(ctx context.Context, burnHeight int, opType string, reqEditors ...RequestEditorFn) (*GetBurnOpsResponse, error) {
	rsp, err := c.GetBurnOps(ctx, burnHeight, opType, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBurnOpsResponse(rsp)
}

// GetConstantValWithResponse request returning *GetConstantValResponse
func (c *ClientWithResponses) GetConstantValWithResponse(ctx context.Context, contractAddress string, contractName string, constantName string, params *GetConstantValParams, reqEditors ...RequestEditorFn) (*GetConstantValResponse, error) {
	rsp, err := c.GetConstantVal(ctx, contractAddress, contractName, constantName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConstantValResponse(rsp)
}

// CallReadOnlyFunctionWithBodyWithResponse request with arbitrary body returning *CallReadOnlyFunctionResponse
func (c *ClientWithResponses) CallReadOnlyFunctionWithBodyWithResponse(ctx context.Context, contractAddress string, contractName string, functionName string, params *CallReadOnlyFunctionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CallReadOnlyFunctionResponse, error) {
	rsp, err := c.CallReadOnlyFunctionWithBody(ctx, contractAddress, contractName, functionName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCallReadOnlyFunctionResponse(rsp)
}

func (c *ClientWithResponses) CallReadOnlyFunctionWithResponse(ctx context.Context, contractAddress string, contractName string, functionName string, params *CallReadOnlyFunctionParams, body CallReadOnlyFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*CallReadOnlyFunctionResponse, error) {
	rsp, err := c.CallReadOnlyFunction(ctx, contractAddress, contractName, functionName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCallReadOnlyFunctionResponse(rsp)
}

// GetContractInterfaceWithResponse request returning *GetContractInterfaceResponse
func (c *ClientWithResponses) GetContractInterfaceWithResponse(ctx context.Context, contractAddress string, contractName string, params *GetContractInterfaceParams, reqEditors ...RequestEditorFn) (*GetContractInterfaceResponse, error) {
	rsp, err := c.GetContractInterface(ctx, contractAddress, contractName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContractInterfaceResponse(rsp)
}

// GetContractSourceWithResponse request returning *GetContractSourceResponse
func (c *ClientWithResponses) GetContractSourceWithResponse(ctx context.Context, contractAddress string, contractName string, params *GetContractSourceParams, reqEditors ...RequestEditorFn) (*GetContractSourceResponse, error) {
	rsp, err := c.GetContractSource(ctx, contractAddress, contractName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContractSourceResponse(rsp)
}

// PostFeeTransactionWithBodyWithResponse request with arbitrary body returning *PostFeeTransactionResponse
func (c *ClientWithResponses) PostFeeTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFeeTransactionResponse, error) {
	rsp, err := c.PostFeeTransactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFeeTransactionResponse(rsp)
}

func (c *ClientWithResponses) PostFeeTransactionWithResponse(ctx context.Context, body PostFeeTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFeeTransactionResponse, error) {
	rsp, err := c.PostFeeTransaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFeeTransactionResponse(rsp)
}

// GetFeeTransferWithResponse request returning *GetFeeTransferResponse
func (c *ClientWithResponses) GetFeeTransferWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFeeTransferResponse, error) {
	rsp, err := c.GetFeeTransfer(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFeeTransferResponse(rsp)
}

// GetCoreApiInfoWithResponse request returning *GetCoreApiInfoResponse
func (c *ClientWithResponses) GetCoreApiInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCoreApiInfoResponse, error) {
	rsp, err := c.GetCoreApiInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCoreApiInfoResponse(rsp)
}

// GetContractDataMapEntryWithBodyWithResponse request with arbitrary body returning *GetContractDataMapEntryResponse
func (c *ClientWithResponses) GetContractDataMapEntryWithBodyWithResponse(ctx context.Context, contractAddress string, contractName string, mapName string, params *GetContractDataMapEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetContractDataMapEntryResponse, error) {
	rsp, err := c.GetContractDataMapEntryWithBody(ctx, contractAddress, contractName, mapName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContractDataMapEntryResponse(rsp)
}

func (c *ClientWithResponses) GetContractDataMapEntryWithResponse(ctx context.Context, contractAddress string, contractName string, mapName string, params *GetContractDataMapEntryParams, body GetContractDataMapEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*GetContractDataMapEntryResponse, error) {
	rsp, err := c.GetContractDataMapEntry(ctx, contractAddress, contractName, mapName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContractDataMapEntryResponse(rsp)
}

// GetPoxInfoWithResponse request returning *GetPoxInfoResponse
func (c *ClientWithResponses) GetPoxInfoWithResponse(ctx context.Context, params *GetPoxInfoParams, reqEditors ...RequestEditorFn) (*GetPoxInfoResponse, error) {
	rsp, err := c.GetPoxInfo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPoxInfoResponse(rsp)
}

// GetStackerSetWithResponse request returning *GetStackerSetResponse
func (c *ClientWithResponses) GetStackerSetWithResponse(ctx context.Context, cycleNumber int, reqEditors ...RequestEditorFn) (*GetStackerSetResponse, error) {
	rsp, err := c.GetStackerSet(ctx, cycleNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStackerSetResponse(rsp)
}

// GetIsTraitImplementedWithResponse request returning *GetIsTraitImplementedResponse
func (c *ClientWithResponses) GetIsTraitImplementedWithResponse(ctx context.Context, contractAddress string, contractName string, traitContractAddress string, traitContractName string, traitName string, params *GetIsTraitImplementedParams, reqEditors ...RequestEditorFn) (*GetIsTraitImplementedResponse, error) {
	rsp, err := c.GetIsTraitImplemented(ctx, contractAddress, contractName, traitContractAddress, traitContractName, traitName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIsTraitImplementedResponse(rsp)
}

// PostCoreNodeTransactionsWithBodyWithResponse request with arbitrary body returning *PostCoreNodeTransactionsResponse
func (c *ClientWithResponses) PostCoreNodeTransactionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCoreNodeTransactionsResponse, error) {
	rsp, err := c.PostCoreNodeTransactionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCoreNodeTransactionsResponse(rsp)
}

// GetBlockV3WithResponse request returning *GetBlockV3Response
func (c *ClientWithResponses) GetBlockV3WithResponse(ctx context.Context, blockId string, reqEditors ...RequestEditorFn) (*GetBlockV3Response, error) {
	rsp, err := c.GetBlockV3(ctx, blockId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlockV3Response(rsp)
}

// GetTenureInfoWithResponse request returning *GetTenureInfoResponse
func (c *ClientWithResponses) GetTenureInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTenureInfoResponse, error) {
	rsp, err := c.GetTenureInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTenureInfoResponse(rsp)
}

// GetTenuresWithResponse request returning *GetTenuresResponse
func (c *ClientWithResponses) GetTenuresWithResponse(ctx context.Context, blockId string, params *GetTenuresParams, reqEditors ...RequestEditorFn) (*GetTenuresResponse, error) {
	rsp, err := c.GetTenures(ctx, blockId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTenuresResponse(rsp)
}

// ParseGetAccountInfoResponse parses an HTTP response from a GetAccountInfoWithResponse call
func ParseGetAccountInfoResponse(rsp *http.Response) (*GetAccountInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Balance      string `json:"balance"`
			BalanceProof string `json:"balance_proof"`
			Locked       string `json:"locked"`
			Nonce        int    `json:"nonce"`
			NonceProof   string `json:"nonce_proof"`
			UnlockHeight int    `json:"unlock_height"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostBlockProposalResponse parses an HTTP response from a PostBlockProposalWithResponse call
func ParsePostBlockProposalResponse(rsp *http.Response) (*PostBlockProposalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostBlockProposalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBurnOpsResponse parses an HTTP response from a GetBurnOpsWithResponse call
func ParseGetBurnOpsResponse(rsp *http.Response) (*GetBurnOpsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBurnOpsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetConstantValResponse parses an HTTP response from a GetConstantValWithResponse call
func ParseGetConstantValResponse(rsp *http.Response) (*GetConstantValResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConstantValResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Hex-encoded string of clarity value.
			Data string `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCallReadOnlyFunctionResponse parses an HTTP response from a CallReadOnlyFunctionWithResponse call
func ParseCallReadOnlyFunctionResponse(rsp *http.Response) (*CallReadOnlyFunctionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CallReadOnlyFunctionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Cause  *string `json:"cause,omitempty"`
			Okay   bool    `json:"okay"`
			Result *string `json:"result,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetContractInterfaceResponse parses an HTTP response from a GetContractInterfaceWithResponse call
func ParseGetContractInterfaceResponse(rsp *http.Response) (*GetContractInterfaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContractInterfaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Functions List of defined methods
			Functions []map[string]interface{} `json:"functions"`

			// FungibleTokens List of fungible tokens in the contract
			FungibleTokens []map[string]interface{} `json:"fungible_tokens"`

			// Maps List of defined data-maps
			Maps []map[string]interface{} `json:"maps"`

			// NonFungibleTokens List of non-fungible tokens in the contract
			NonFungibleTokens []map[string]interface{} `json:"non_fungible_tokens"`

			// Variables List of defined variables
			Variables []map[string]interface{} `json:"variables"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetContractSourceResponse parses an HTTP response from a GetContractSourceWithResponse call
func ParseGetContractSourceResponse(rsp *http.Response) (*GetContractSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContractSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Proof         string `json:"proof"`
			PublishHeight int    `json:"publish_height"`
			Source        string `json:"source"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostFeeTransactionResponse parses an HTTP response from a PostFeeTransactionWithResponse call
func ParsePostFeeTransactionResponse(rsp *http.Response) (*PostFeeTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFeeTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CostScalarChangeByByte *float32 `json:"cost_scalar_change_by_byte,omitempty"`
			EstimatedCost          struct {
				ReadCount   int `json:"read_count"`
				ReadLength  int `json:"read_length"`
				Runtime     int `json:"runtime"`
				WriteCount  int `json:"write_count"`
				WriteLength int `json:"write_length"`
			} `json:"estimated_cost"`
			EstimatedCostScalar int `json:"estimated_cost_scalar"`
			Estimations         *[]struct {
				Fee     *float32 `json:"fee,omitempty"`
				FeeRate *float32 `json:"fee_rate,omitempty"`
			} `json:"estimations,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFeeTransferResponse parses an HTTP response from a GetFeeTransferWithResponse call
func ParseGetFeeTransferResponse(rsp *http.Response) (*GetFeeTransferResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFeeTransferResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCoreApiInfoResponse parses an HTTP response from a GetCoreApiInfoWithResponse call
func ParseGetCoreApiInfoResponse(rsp *http.Response) (*GetCoreApiInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCoreApiInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// BurnBlockHeight latest bitcoin chain height
			BurnBlockHeight int `json:"burn_block_height"`

			// ExitAtBlockHeight the block height at which the testnet network will be reset. not applicable for mainnet
			ExitAtBlockHeight int `json:"exit_at_block_height"`

			// NetworkId is similar to peer_version and will be used to differentiate between different testnets. this value will be different between mainnet and testnet. once launched, this value will not change
			NetworkId int `json:"network_id"`

			// ParentNetworkId same as network_id, but for bitcoin
			ParentNetworkId int `json:"parent_network_id"`

			// PeerVersion identifies the version number for the networking communication, this should not change while a node is running, and will only change if there's an upgrade
			PeerVersion int `json:"peer_version"`

			// PoxConsensus is a hash used to identify the burnchain view for a node. it incorporates bitcoin chain information and PoX information. nodes that disagree on this value will appear to each other as forks. this value will change after every block
			PoxConsensus string `json:"pox_consensus"`

			// ServerVersion is a version descriptor
			ServerVersion string `json:"server_version"`

			// StableBurnBlockHeight leftover from stacks 1.0, basically always burn_block_height - 1
			StableBurnBlockHeight int `json:"stable_burn_block_height"`

			// StablePoxConsensus same as burn_consensus, but evaluated at stable_burn_block_height
			StablePoxConsensus string `json:"stable_pox_consensus"`

			// StacksTip the best known block hash for the Stack chain (not including any pending microblocks)
			StacksTip string `json:"stacks_tip"`

			// StacksTipConsensusHash the burn chain (i.e., bitcoin) consensus hash at the time that stacks_tip was mined
			StacksTipConsensusHash string `json:"stacks_tip_consensus_hash"`

			// StacksTipHeight the latest Stacks chain height. Stacks forks can occur independent of the Bitcoin chain, that height doesn't increase 1-to-1 with the Bitcoin height
			StacksTipHeight int `json:"stacks_tip_height"`

			// UnanchoredTip the latest microblock hash if any microblocks were processed. if no microblock has been processed for the current block, a 000.., hex array is returned
			UnanchoredTip string `json:"unanchored_tip"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetContractDataMapEntryResponse parses an HTTP response from a GetContractDataMapEntryWithResponse call
func ParseGetContractDataMapEntryResponse(rsp *http.Response) (*GetContractDataMapEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContractDataMapEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Hex-encoded string of clarity value. It is always an optional tuple.
			Data string `json:"data"`

			// Proof Hex-encoded string of the MARF proof for the data
			Proof *string `json:"proof,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPoxInfoResponse parses an HTTP response from a GetPoxInfoWithResponse call
func ParseGetPoxInfoResponse(rsp *http.Response) (*GetPoxInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPoxInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ContractId The contract identifier for the PoX contract
			ContractId string `json:"contract_id"`

			// ContractVersions Versions of each PoX
			ContractVersions []struct {
				// ActivationBurnchainBlockHeight The burn block height at which this version of PoX is activated
				ActivationBurnchainBlockHeight int `json:"activation_burnchain_block_height"`

				// ContractId The contract identifier for the PoX contract
				ContractId string `json:"contract_id"`

				// FirstRewardCycleId The first reward cycle number that uses this version of PoX
				FirstRewardCycleId int `json:"first_reward_cycle_id"`
			} `json:"contract_versions"`

			// CurrentBurnchainBlockHeight The latest Bitcoin chain block height
			CurrentBurnchainBlockHeight int `json:"current_burnchain_block_height"`
			CurrentCycle                struct {
				// Id The reward cycle number
				Id int `json:"id"`

				// IsPoxActive Whether or not PoX is active during this reward cycle.
				IsPoxActive bool `json:"is_pox_active"`

				// MinThresholdUstx The threshold amount for obtaining a slot in this reward cycle.
				MinThresholdUstx int `json:"min_threshold_ustx"`

				// StackedUstx The total amount of stacked microstacks in this reward cycle.
				StackedUstx int `json:"stacked_ustx"`
			} `json:"current_cycle"`

			// FirstBurnchainBlockHeight The first burn block evaluated in this Stacks chain
			FirstBurnchainBlockHeight int `json:"first_burnchain_block_height"`
			// Deprecated:
			MinAmountUstx int `json:"min_amount_ustx"`
			NextCycle     struct {
				// BlocksUntilPreparePhase The number of burn blocks until the prepare phase for this cycle starts. If the prepare phase for this cycle already started, this value will be negative.
				BlocksUntilPreparePhase int `json:"blocks_until_prepare_phase"`

				// BlocksUntilRewardPhase The number of burn blocks until this reward phase starts.
				BlocksUntilRewardPhase int `json:"blocks_until_reward_phase"`

				// Id The reward cycle number
				Id int `json:"id"`

				// MinIncrementUstx The minimum amount that can be used to submit a `stack-stx` call.
				MinIncrementUstx int `json:"min_increment_ustx"`

				// MinThresholdUstx The threshold amount for obtaining a slot in this reward cycle.
				MinThresholdUstx int `json:"min_threshold_ustx"`

				// PreparePhaseStartBlockHeight The burn block height when the prepare phase for this cycle begins. Any eligible stacks must be stacked before this block.
				PreparePhaseStartBlockHeight int `json:"prepare_phase_start_block_height"`

				// RewardPhaseStartBlockHeight The burn block height when the reward phase for this cycle begins. Any eligible stacks must be stacked before this block.
				RewardPhaseStartBlockHeight int `json:"reward_phase_start_block_height"`

				// StackedUstx The total amount of stacked microstacks in this reward cycle.
				StackedUstx int `json:"stacked_ustx"`

				// UstxUntilPoxRejection The remaining amount of liquid STX that must vote to reject the next reward cycle to prevent the next reward cycle from activating.
				UstxUntilPoxRejection int `json:"ustx_until_pox_rejection"`
			} `json:"next_cycle"`

			// PoxActivationThresholdUstx The threshold of stacking participation that must be reached for PoX to activate in any cycle
			PoxActivationThresholdUstx int `json:"pox_activation_threshold_ustx"`
			// Deprecated:
			PrepareCycleLength int `json:"prepare_cycle_length"`

			// PreparePhaseBlockLength The length in burn blocks of the prepare phase
			PreparePhaseBlockLength int `json:"prepare_phase_block_length"`

			// RejectionFraction The fraction of liquid STX that must vote to reject PoX in order to prevent the next reward cycle from activating.
			RejectionFraction int `json:"rejection_fraction"`
			// Deprecated:
			RejectionVotesLeftRequired int `json:"rejection_votes_left_required"`

			// RewardCycleId The active reward cycle number
			// Deprecated:
			RewardCycleId int `json:"reward_cycle_id"`

			// RewardCycleLength The length in burn blocks of a whole PoX cycle (reward phase and prepare phase)
			RewardCycleLength int `json:"reward_cycle_length"`

			// RewardPhaseBlockLength The length in burn blocks of the reward phase
			RewardPhaseBlockLength int `json:"reward_phase_block_length"`

			// RewardSlots The number of reward slots in a reward cycle
			RewardSlots int `json:"reward_slots"`

			// TotalLiquidSupplyUstx The current total amount of liquid microstacks.
			TotalLiquidSupplyUstx int `json:"total_liquid_supply_ustx"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetStackerSetResponse parses an HTTP response from a GetStackerSetWithResponse call
func ParseGetStackerSetResponse(rsp *http.Response) (*GetStackerSetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStackerSetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetIsTraitImplementedResponse parses an HTTP response from a GetIsTraitImplementedWithResponse call
func ParseGetIsTraitImplementedResponse(rsp *http.Response) (*GetIsTraitImplementedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIsTraitImplementedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsImplemented bool `json:"is_implemented"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostCoreNodeTransactionsResponse parses an HTTP response from a PostCoreNodeTransactionsWithResponse call
func ParsePostCoreNodeTransactionsResponse(rsp *http.Response) (*PostCoreNodeTransactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCoreNodeTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error The error
			Error string `json:"error"`

			// Reason The reason for the error
			Reason string `json:"reason"`

			// ReasonData More details about the reason
			ReasonData map[string]interface{} `json:"reason_data"`

			// Txid The relevant transaction id
			Txid string `json:"txid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetBlockV3Response parses an HTTP response from a GetBlockV3WithResponse call
func ParseGetBlockV3Response(rsp *http.Response) (*GetBlockV3Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlockV3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTenureInfoResponse parses an HTTP response from a GetTenureInfoWithResponse call
func ParseGetTenureInfoResponse(rsp *http.Response) (*GetTenureInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTenureInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTenuresResponse parses an HTTP response from a GetTenuresWithResponse call
func ParseGetTenuresResponse(rsp *http.Response) (*GetTenuresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTenuresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account info
	// (GET /v2/accounts/{principal})
	GetAccountInfo(ctx echo.Context, principal string, params GetAccountInfoParams) error
	// Validate a proposed Stacks block
	// (POST /v2/block_proposal)
	PostBlockProposal(ctx echo.Context) error
	// Get burn operations
	// (GET /v2/burn_ops/{burn_height}/{op_type})
	GetBurnOps(ctx echo.Context, burnHeight int, opType string) error
	// Get the value of a constant inside a contract
	// (POST /v2/constant_val/{contract_address}/{contract_name}/{constant_name})
	GetConstantVal(ctx echo.Context, contractAddress string, contractName string, constantName string, params GetConstantValParams) error
	// Call read-only function
	// (POST /v2/contracts/call-read/{contract_address}/{contract_name}/{function_name})
	CallReadOnlyFunction(ctx echo.Context, contractAddress string, contractName string, functionName string, params CallReadOnlyFunctionParams) error
	// Get contract interface
	// (GET /v2/contracts/interface/{contract_address}/{contract_name})
	GetContractInterface(ctx echo.Context, contractAddress string, contractName string, params GetContractInterfaceParams) error
	// Get contract source
	// (GET /v2/contracts/source/{contract_address}/{contract_name})
	GetContractSource(ctx echo.Context, contractAddress string, contractName string, params GetContractSourceParams) error
	// Get approximate fees for the given transaction
	// (POST /v2/fees/transaction)
	PostFeeTransaction(ctx echo.Context) error
	// Get estimated fee
	// (GET /v2/fees/transfer)
	GetFeeTransfer(ctx echo.Context) error
	// Get Core API info
	// (GET /v2/info)
	GetCoreApiInfo(ctx echo.Context) error
	// Get specific data-map inside a contract
	// (POST /v2/map_entry/{contract_address}/{contract_name}/{map_name})
	GetContractDataMapEntry(ctx echo.Context, contractAddress string, contractName string, mapName string, params GetContractDataMapEntryParams) error
	// Get PoX details
	// (GET /v2/pox)
	GetPoxInfo(ctx echo.Context, params GetPoxInfoParams) error
	// Fetch the stacker and signer set information for a given cycle.
	// (GET /v2/stacker_set/{cycle_number})
	GetStackerSet(ctx echo.Context, cycleNumber int) error
	// Get trait implementation details
	// (GET /v2/traits/{contract_address}/{contract_name}/{trait_contract_address}/{trait_contract_name}/{trait_name})
	GetIsTraitImplemented(ctx echo.Context, contractAddress string, contractName string, traitContractAddress string, traitContractName string, traitName string, params GetIsTraitImplementedParams) error
	// Broadcast raw transaction
	// (POST /v2/transactions)
	PostCoreNodeTransactions(ctx echo.Context) error
	// Fetch a Nakamoto block
	// (GET /v3/blocks/{block_id})
	GetBlockV3(ctx echo.Context, blockId string) error
	// Fetch metadata about the ongoing Nakamoto tenure
	// (GET /v3/tenures/info)
	GetTenureInfo(ctx echo.Context) error
	// Fetch a sequence of Nakamoto blocks in a tenure
	// (GET /v3/tenures/{block_id})
	GetTenures(ctx echo.Context, blockId string, params GetTenuresParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAccountInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetAccountInfo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "principal" -------------
	var principal string

	err = runtime.BindStyledParameterWithOptions("simple", "principal", ctx.Param("principal"), &principal, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter principal: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAccountInfoParams
	// ------------- Optional query parameter "proof" -------------

	err = runtime.BindQueryParameter("form", true, false, "proof", ctx.QueryParams(), &params.Proof)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proof: %s", err))
	}

	// ------------- Optional query parameter "tip" -------------

	err = runtime.BindQueryParameter("form", true, false, "tip", ctx.QueryParams(), &params.Tip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tip: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAccountInfo(ctx, principal, params)
	return err
}

// PostBlockProposal converts echo context to params.
func (w *ServerInterfaceWrapper) PostBlockProposal(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostBlockProposal(ctx)
	return err
}

// GetBurnOps converts echo context to params.
func (w *ServerInterfaceWrapper) GetBurnOps(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "burn_height" -------------
	var burnHeight int

	err = runtime.BindStyledParameterWithOptions("simple", "burn_height", ctx.Param("burn_height"), &burnHeight, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter burn_height: %s", err))
	}

	// ------------- Path parameter "op_type" -------------
	var opType string

	err = runtime.BindStyledParameterWithOptions("simple", "op_type", ctx.Param("op_type"), &opType, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter op_type: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBurnOps(ctx, burnHeight, opType)
	return err
}

// GetConstantVal converts echo context to params.
func (w *ServerInterfaceWrapper) GetConstantVal(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "contract_address" -------------
	var contractAddress string

	err = runtime.BindStyledParameterWithOptions("simple", "contract_address", ctx.Param("contract_address"), &contractAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter contract_address: %s", err))
	}

	// ------------- Path parameter "contract_name" -------------
	var contractName string

	err = runtime.BindStyledParameterWithOptions("simple", "contract_name", ctx.Param("contract_name"), &contractName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter contract_name: %s", err))
	}

	// ------------- Path parameter "constant_name" -------------
	var constantName string

	err = runtime.BindStyledParameterWithOptions("simple", "constant_name", ctx.Param("constant_name"), &constantName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter constant_name: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetConstantValParams
	// ------------- Optional query parameter "tip" -------------

	err = runtime.BindQueryParameter("form", true, false, "tip", ctx.QueryParams(), &params.Tip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tip: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetConstantVal(ctx, contractAddress, contractName, constantName, params)
	return err
}

// CallReadOnlyFunction converts echo context to params.
func (w *ServerInterfaceWrapper) CallReadOnlyFunction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "contract_address" -------------
	var contractAddress string

	err = runtime.BindStyledParameterWithOptions("simple", "contract_address", ctx.Param("contract_address"), &contractAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter contract_address: %s", err))
	}

	// ------------- Path parameter "contract_name" -------------
	var contractName string

	err = runtime.BindStyledParameterWithOptions("simple", "contract_name", ctx.Param("contract_name"), &contractName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter contract_name: %s", err))
	}

	// ------------- Path parameter "function_name" -------------
	var functionName string

	err = runtime.BindStyledParameterWithOptions("simple", "function_name", ctx.Param("function_name"), &functionName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter function_name: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params CallReadOnlyFunctionParams
	// ------------- Optional query parameter "tip" -------------

	err = runtime.BindQueryParameter("form", true, false, "tip", ctx.QueryParams(), &params.Tip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tip: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CallReadOnlyFunction(ctx, contractAddress, contractName, functionName, params)
	return err
}

// GetContractInterface converts echo context to params.
func (w *ServerInterfaceWrapper) GetContractInterface(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "contract_address" -------------
	var contractAddress string

	err = runtime.BindStyledParameterWithOptions("simple", "contract_address", ctx.Param("contract_address"), &contractAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter contract_address: %s", err))
	}

	// ------------- Path parameter "contract_name" -------------
	var contractName string

	err = runtime.BindStyledParameterWithOptions("simple", "contract_name", ctx.Param("contract_name"), &contractName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter contract_name: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetContractInterfaceParams
	// ------------- Optional query parameter "tip" -------------

	err = runtime.BindQueryParameter("form", true, false, "tip", ctx.QueryParams(), &params.Tip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tip: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetContractInterface(ctx, contractAddress, contractName, params)
	return err
}

// GetContractSource converts echo context to params.
func (w *ServerInterfaceWrapper) GetContractSource(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "contract_address" -------------
	var contractAddress string

	err = runtime.BindStyledParameterWithOptions("simple", "contract_address", ctx.Param("contract_address"), &contractAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter contract_address: %s", err))
	}

	// ------------- Path parameter "contract_name" -------------
	var contractName string

	err = runtime.BindStyledParameterWithOptions("simple", "contract_name", ctx.Param("contract_name"), &contractName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter contract_name: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetContractSourceParams
	// ------------- Optional query parameter "proof" -------------

	err = runtime.BindQueryParameter("form", true, false, "proof", ctx.QueryParams(), &params.Proof)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proof: %s", err))
	}

	// ------------- Optional query parameter "tip" -------------

	err = runtime.BindQueryParameter("form", true, false, "tip", ctx.QueryParams(), &params.Tip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tip: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetContractSource(ctx, contractAddress, contractName, params)
	return err
}

// PostFeeTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) PostFeeTransaction(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFeeTransaction(ctx)
	return err
}

// GetFeeTransfer converts echo context to params.
func (w *ServerInterfaceWrapper) GetFeeTransfer(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFeeTransfer(ctx)
	return err
}

// GetCoreApiInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetCoreApiInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCoreApiInfo(ctx)
	return err
}

// GetContractDataMapEntry converts echo context to params.
func (w *ServerInterfaceWrapper) GetContractDataMapEntry(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "contract_address" -------------
	var contractAddress string

	err = runtime.BindStyledParameterWithOptions("simple", "contract_address", ctx.Param("contract_address"), &contractAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter contract_address: %s", err))
	}

	// ------------- Path parameter "contract_name" -------------
	var contractName string

	err = runtime.BindStyledParameterWithOptions("simple", "contract_name", ctx.Param("contract_name"), &contractName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter contract_name: %s", err))
	}

	// ------------- Path parameter "map_name" -------------
	var mapName string

	err = runtime.BindStyledParameterWithOptions("simple", "map_name", ctx.Param("map_name"), &mapName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter map_name: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetContractDataMapEntryParams
	// ------------- Optional query parameter "proof" -------------

	err = runtime.BindQueryParameter("form", true, false, "proof", ctx.QueryParams(), &params.Proof)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proof: %s", err))
	}

	// ------------- Optional query parameter "tip" -------------

	err = runtime.BindQueryParameter("form", true, false, "tip", ctx.QueryParams(), &params.Tip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tip: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetContractDataMapEntry(ctx, contractAddress, contractName, mapName, params)
	return err
}

// GetPoxInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetPoxInfo(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPoxInfoParams
	// ------------- Optional query parameter "tip" -------------

	err = runtime.BindQueryParameter("form", true, false, "tip", ctx.QueryParams(), &params.Tip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tip: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPoxInfo(ctx, params)
	return err
}

// GetStackerSet converts echo context to params.
func (w *ServerInterfaceWrapper) GetStackerSet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "cycle_number" -------------
	var cycleNumber int

	err = runtime.BindStyledParameterWithOptions("simple", "cycle_number", ctx.Param("cycle_number"), &cycleNumber, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cycle_number: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStackerSet(ctx, cycleNumber)
	return err
}

// GetIsTraitImplemented converts echo context to params.
func (w *ServerInterfaceWrapper) GetIsTraitImplemented(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "contract_address" -------------
	var contractAddress string

	err = runtime.BindStyledParameterWithOptions("simple", "contract_address", ctx.Param("contract_address"), &contractAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter contract_address: %s", err))
	}

	// ------------- Path parameter "contract_name" -------------
	var contractName string

	err = runtime.BindStyledParameterWithOptions("simple", "contract_name", ctx.Param("contract_name"), &contractName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter contract_name: %s", err))
	}

	// ------------- Path parameter "trait_contract_address" -------------
	var traitContractAddress string

	err = runtime.BindStyledParameterWithOptions("simple", "trait_contract_address", ctx.Param("trait_contract_address"), &traitContractAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter trait_contract_address: %s", err))
	}

	// ------------- Path parameter "trait_contract_name" -------------
	var traitContractName string

	err = runtime.BindStyledParameterWithOptions("simple", "trait_contract_name", ctx.Param("trait_contract_name"), &traitContractName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter trait_contract_name: %s", err))
	}

	// ------------- Path parameter "trait_name" -------------
	var traitName string

	err = runtime.BindStyledParameterWithOptions("simple", "trait_name", ctx.Param("trait_name"), &traitName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter trait_name: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetIsTraitImplementedParams
	// ------------- Optional query parameter "tip" -------------

	err = runtime.BindQueryParameter("form", true, false, "tip", ctx.QueryParams(), &params.Tip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tip: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetIsTraitImplemented(ctx, contractAddress, contractName, traitContractAddress, traitContractName, traitName, params)
	return err
}

// PostCoreNodeTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) PostCoreNodeTransactions(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostCoreNodeTransactions(ctx)
	return err
}

// GetBlockV3 converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockV3(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "block_id" -------------
	var blockId string

	err = runtime.BindStyledParameterWithOptions("simple", "block_id", ctx.Param("block_id"), &blockId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter block_id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockV3(ctx, blockId)
	return err
}

// GetTenureInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetTenureInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTenureInfo(ctx)
	return err
}

// GetTenures converts echo context to params.
func (w *ServerInterfaceWrapper) GetTenures(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "block_id" -------------
	var blockId string

	err = runtime.BindStyledParameterWithOptions("simple", "block_id", ctx.Param("block_id"), &blockId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter block_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTenuresParams
	// ------------- Optional query parameter "stop" -------------

	err = runtime.BindQueryParameter("form", true, false, "stop", ctx.QueryParams(), &params.Stop)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stop: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTenures(ctx, blockId, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:principal", wrapper.GetAccountInfo)
	router.POST(baseURL+"/v2/block_proposal", wrapper.PostBlockProposal)
	router.GET(baseURL+"/v2/burn_ops/:burn_height/:op_type", wrapper.GetBurnOps)
	router.POST(baseURL+"/v2/constant_val/:contract_address/:contract_name/:constant_name", wrapper.GetConstantVal)
	router.POST(baseURL+"/v2/contracts/call-read/:contract_address/:contract_name/:function_name", wrapper.CallReadOnlyFunction)
	router.GET(baseURL+"/v2/contracts/interface/:contract_address/:contract_name", wrapper.GetContractInterface)
	router.GET(baseURL+"/v2/contracts/source/:contract_address/:contract_name", wrapper.GetContractSource)
	router.POST(baseURL+"/v2/fees/transaction", wrapper.PostFeeTransaction)
	router.GET(baseURL+"/v2/fees/transfer", wrapper.GetFeeTransfer)
	router.GET(baseURL+"/v2/info", wrapper.GetCoreApiInfo)
	router.POST(baseURL+"/v2/map_entry/:contract_address/:contract_name/:map_name", wrapper.GetContractDataMapEntry)
	router.GET(baseURL+"/v2/pox", wrapper.GetPoxInfo)
	router.GET(baseURL+"/v2/stacker_set/:cycle_number", wrapper.GetStackerSet)
	router.GET(baseURL+"/v2/traits/:contract_address/:contract_name/:trait_contract_address/:trait_contract_name/:trait_name", wrapper.GetIsTraitImplemented)
	router.POST(baseURL+"/v2/transactions", wrapper.PostCoreNodeTransactions)
	router.GET(baseURL+"/v3/blocks/:block_id", wrapper.GetBlockV3)
	router.GET(baseURL+"/v3/tenures/info", wrapper.GetTenureInfo)
	router.GET(baseURL+"/v3/tenures/:block_id", wrapper.GetTenures)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"JkYR44QAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
