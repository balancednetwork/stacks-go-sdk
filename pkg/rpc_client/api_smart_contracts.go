/*
Stacks 2.0+ RPC API

This is the documentation for the `stacks-node` RPC interface. 

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rpc_client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SmartContractsAPIService SmartContractsAPI service
type SmartContractsAPIService service

type ApiCallReadOnlyFunctionRequest struct {
	ctx context.Context
	ApiService *SmartContractsAPIService
	contractAddress string
	contractName string
	functionName string
	readOnlyFunctionArgsschema *ReadOnlyFunctionArgsschema
	tip *string
}

// map of arguments and the simulated tx-sender where sender is either a Contract identifier or a normal Stacks address, and arguments is an array of hex serialized Clarity values.
func (r ApiCallReadOnlyFunctionRequest) ReadOnlyFunctionArgsschema(readOnlyFunctionArgsschema ReadOnlyFunctionArgsschema) ApiCallReadOnlyFunctionRequest {
	r.readOnlyFunctionArgsschema = &readOnlyFunctionArgsschema
	return r
}

// The Stacks chain tip to query from. If tip &#x3D;&#x3D; latest, the query will be run from the latest known tip (includes unconfirmed state).
func (r ApiCallReadOnlyFunctionRequest) Tip(tip string) ApiCallReadOnlyFunctionRequest {
	r.tip = &tip
	return r
}

func (r ApiCallReadOnlyFunctionRequest) Execute() (*PostCallReadOnlyFnschema, *http.Response, error) {
	return r.ApiService.CallReadOnlyFunctionExecute(r)
}

/*
CallReadOnlyFunction Call read-only function

Call a read-only public function on a given smart contract.

The smart contract and function are specified using the URL path. The arguments and the simulated tx-sender are supplied via the POST body in the following JSON format:


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractAddress Stacks address
 @param contractName Contract name
 @param functionName Function name
 @return ApiCallReadOnlyFunctionRequest
*/
func (a *SmartContractsAPIService) CallReadOnlyFunction(ctx context.Context, contractAddress string, contractName string, functionName string) ApiCallReadOnlyFunctionRequest {
	return ApiCallReadOnlyFunctionRequest{
		ApiService: a,
		ctx: ctx,
		contractAddress: contractAddress,
		contractName: contractName,
		functionName: functionName,
	}
}

// Execute executes the request
//  @return PostCallReadOnlyFnschema
func (a *SmartContractsAPIService) CallReadOnlyFunctionExecute(r ApiCallReadOnlyFunctionRequest) (*PostCallReadOnlyFnschema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostCallReadOnlyFnschema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmartContractsAPIService.CallReadOnlyFunction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/contracts/call-read/{contract_address}/{contract_name}/{function_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"contract_address"+"}", url.PathEscape(parameterValueToString(r.contractAddress, "contractAddress")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contract_name"+"}", url.PathEscape(parameterValueToString(r.contractName, "contractName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"function_name"+"}", url.PathEscape(parameterValueToString(r.functionName, "functionName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.readOnlyFunctionArgsschema == nil {
		return localVarReturnValue, nil, reportError("readOnlyFunctionArgsschema is required and must be specified")
	}

	if r.tip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tip", r.tip, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.readOnlyFunctionArgsschema
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConstantValRequest struct {
	ctx context.Context
	ApiService *SmartContractsAPIService
	contractAddress string
	contractName string
	constantName string
	tip *string
}

// The Stacks chain tip to query from. If tip &#x3D;&#x3D; latest, the query will be run from the latest known tip (includes unconfirmed state).
func (r ApiGetConstantValRequest) Tip(tip string) ApiGetConstantValRequest {
	r.tip = &tip
	return r
}

func (r ApiGetConstantValRequest) Execute() (*map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetConstantValExecute(r)
}

/*
GetConstantVal Get the value of a constant inside a contract

Attempt to fetch the value of a constant inside a contract. The contract is identified with [Stacks Address] and [Contract Name] in the URL path. The constant is identified with [Constant Name].

In the response, `data` is the hex serialization of the constant value.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractAddress Stacks address
 @param contractName Contract name
 @param constantName Constant name
 @return ApiGetConstantValRequest
*/
func (a *SmartContractsAPIService) GetConstantVal(ctx context.Context, contractAddress string, contractName string, constantName string) ApiGetConstantValRequest {
	return ApiGetConstantValRequest{
		ApiService: a,
		ctx: ctx,
		contractAddress: contractAddress,
		contractName: contractName,
		constantName: constantName,
	}
}

// Execute executes the request
//  @return Object
func (a *SmartContractsAPIService) GetConstantValExecute(r ApiGetConstantValRequest) (*map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmartContractsAPIService.GetConstantVal")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/constant_val/{contract_address}/{contract_name}/{constant_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"contract_address"+"}", url.PathEscape(parameterValueToString(r.contractAddress, "contractAddress")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contract_name"+"}", url.PathEscape(parameterValueToString(r.contractName, "contractName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"constant_name"+"}", url.PathEscape(parameterValueToString(r.constantName, "constantName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tip", r.tip, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContractDataMapEntryRequest struct {
	ctx context.Context
	ApiService *SmartContractsAPIService
	contractAddress string
	contractName string
	mapName string
	key *string
	proof *int32
	tip *string
}

// Hex string serialization of the lookup key (which should be a Clarity value)
func (r ApiGetContractDataMapEntryRequest) Key(key string) ApiGetContractDataMapEntryRequest {
	r.key = &key
	return r
}

// Returns object without the proof field when set to 0
func (r ApiGetContractDataMapEntryRequest) Proof(proof int32) ApiGetContractDataMapEntryRequest {
	r.proof = &proof
	return r
}

// The Stacks chain tip to query from. If tip &#x3D;&#x3D; latest, the query will be run from the latest known tip (includes unconfirmed state).
func (r ApiGetContractDataMapEntryRequest) Tip(tip string) ApiGetContractDataMapEntryRequest {
	r.tip = &tip
	return r
}

func (r ApiGetContractDataMapEntryRequest) Execute() (*GetContractDataMapEntryschema, *http.Response, error) {
	return r.ApiService.GetContractDataMapEntryExecute(r)
}

/*
GetContractDataMapEntry Get specific data-map inside a contract

Attempt to fetch data from a contract data map. The contract is identified with [Stacks Address] and [Contract Name] in the URL path. The map is identified with [Map Name].

The key to lookup in the map is supplied via the POST body. This should be supplied as the hex string serialization of the key (which should be a Clarity value). Note, this is a JSON string atom.

In the response, `data` is the hex serialization of the map response. Note that map responses are Clarity option types, for non-existent values, this is a serialized none, and for all other responses, it is a serialized (some ...) object.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractAddress Stacks address
 @param contractName Contract name
 @param mapName Map name
 @return ApiGetContractDataMapEntryRequest
*/
func (a *SmartContractsAPIService) GetContractDataMapEntry(ctx context.Context, contractAddress string, contractName string, mapName string) ApiGetContractDataMapEntryRequest {
	return ApiGetContractDataMapEntryRequest{
		ApiService: a,
		ctx: ctx,
		contractAddress: contractAddress,
		contractName: contractName,
		mapName: mapName,
	}
}

// Execute executes the request
//  @return GetContractDataMapEntryschema
func (a *SmartContractsAPIService) GetContractDataMapEntryExecute(r ApiGetContractDataMapEntryRequest) (*GetContractDataMapEntryschema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetContractDataMapEntryschema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmartContractsAPIService.GetContractDataMapEntry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/map_entry/{contract_address}/{contract_name}/{map_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"contract_address"+"}", url.PathEscape(parameterValueToString(r.contractAddress, "contractAddress")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contract_name"+"}", url.PathEscape(parameterValueToString(r.contractName, "contractName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"map_name"+"}", url.PathEscape(parameterValueToString(r.mapName, "mapName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.key == nil {
		return localVarReturnValue, nil, reportError("key is required and must be specified")
	}

	if r.proof != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "proof", r.proof, "form", "")
	}
	if r.tip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tip", r.tip, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.key
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContractInterfaceRequest struct {
	ctx context.Context
	ApiService *SmartContractsAPIService
	contractAddress string
	contractName string
	tip *string
}

// The Stacks chain tip to query from. If tip &#x3D;&#x3D; latest, the query will be run from the latest known tip (includes unconfirmed state).
func (r ApiGetContractInterfaceRequest) Tip(tip string) ApiGetContractInterfaceRequest {
	r.tip = &tip
	return r
}

func (r ApiGetContractInterfaceRequest) Execute() (*GetContractInterfaceschema, *http.Response, error) {
	return r.ApiService.GetContractInterfaceExecute(r)
}

/*
GetContractInterface Get contract interface

Get contract interface using a `contract_address` and `contract name`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractAddress Stacks address
 @param contractName Contract name
 @return ApiGetContractInterfaceRequest
*/
func (a *SmartContractsAPIService) GetContractInterface(ctx context.Context, contractAddress string, contractName string) ApiGetContractInterfaceRequest {
	return ApiGetContractInterfaceRequest{
		ApiService: a,
		ctx: ctx,
		contractAddress: contractAddress,
		contractName: contractName,
	}
}

// Execute executes the request
//  @return GetContractInterfaceschema
func (a *SmartContractsAPIService) GetContractInterfaceExecute(r ApiGetContractInterfaceRequest) (*GetContractInterfaceschema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetContractInterfaceschema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmartContractsAPIService.GetContractInterface")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/contracts/interface/{contract_address}/{contract_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"contract_address"+"}", url.PathEscape(parameterValueToString(r.contractAddress, "contractAddress")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contract_name"+"}", url.PathEscape(parameterValueToString(r.contractName, "contractName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tip", r.tip, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContractSourceRequest struct {
	ctx context.Context
	ApiService *SmartContractsAPIService
	contractAddress string
	contractName string
	proof *int32
	tip *string
}

// Returns object without the proof field if set to 0
func (r ApiGetContractSourceRequest) Proof(proof int32) ApiGetContractSourceRequest {
	r.proof = &proof
	return r
}

// The Stacks chain tip to query from. If tip &#x3D;&#x3D; latest, the query will be run from the latest known tip (includes unconfirmed state).
func (r ApiGetContractSourceRequest) Tip(tip string) ApiGetContractSourceRequest {
	r.tip = &tip
	return r
}

func (r ApiGetContractSourceRequest) Execute() (*GetContractSourceschema, *http.Response, error) {
	return r.ApiService.GetContractSourceExecute(r)
}

/*
GetContractSource Get contract source

Returns the Clarity source code of a given contract, along with the block height it was published in, and the MARF proof for the data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractAddress Stacks address
 @param contractName Contract name
 @return ApiGetContractSourceRequest
*/
func (a *SmartContractsAPIService) GetContractSource(ctx context.Context, contractAddress string, contractName string) ApiGetContractSourceRequest {
	return ApiGetContractSourceRequest{
		ApiService: a,
		ctx: ctx,
		contractAddress: contractAddress,
		contractName: contractName,
	}
}

// Execute executes the request
//  @return GetContractSourceschema
func (a *SmartContractsAPIService) GetContractSourceExecute(r ApiGetContractSourceRequest) (*GetContractSourceschema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetContractSourceschema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmartContractsAPIService.GetContractSource")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/contracts/source/{contract_address}/{contract_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"contract_address"+"}", url.PathEscape(parameterValueToString(r.contractAddress, "contractAddress")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contract_name"+"}", url.PathEscape(parameterValueToString(r.contractName, "contractName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.proof != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "proof", r.proof, "form", "")
	}
	if r.tip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tip", r.tip, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIsTraitImplementedRequest struct {
	ctx context.Context
	ApiService *SmartContractsAPIService
	contractAddress string
	contractName string
	traitContractAddress string
	traitContractName string
	traitName string
	tip *string
}

// The Stacks chain tip to query from. If tip &#x3D;&#x3D; \&quot;latest\&quot;, the query will be run from the latest known tip (includes unconfirmed state). If the tip is left unspecified, the stacks chain tip will be selected (only includes confirmed state).  
func (r ApiGetIsTraitImplementedRequest) Tip(tip string) ApiGetIsTraitImplementedRequest {
	r.tip = &tip
	return r
}

func (r ApiGetIsTraitImplementedRequest) Execute() (*map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetIsTraitImplementedExecute(r)
}

/*
GetIsTraitImplemented Get trait implementation details

Determine whether or not a specified trait is implemented (either explicitly or implicitly) within a given contract.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractAddress Stacks address
 @param contractName Contract name
 @param traitContractAddress Trait Stacks address
 @param traitContractName Trait contract name
 @param traitName Trait name
 @return ApiGetIsTraitImplementedRequest
*/
func (a *SmartContractsAPIService) GetIsTraitImplemented(ctx context.Context, contractAddress string, contractName string, traitContractAddress string, traitContractName string, traitName string) ApiGetIsTraitImplementedRequest {
	return ApiGetIsTraitImplementedRequest{
		ApiService: a,
		ctx: ctx,
		contractAddress: contractAddress,
		contractName: contractName,
		traitContractAddress: traitContractAddress,
		traitContractName: traitContractName,
		traitName: traitName,
	}
}

// Execute executes the request
//  @return Object
func (a *SmartContractsAPIService) GetIsTraitImplementedExecute(r ApiGetIsTraitImplementedRequest) (*map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmartContractsAPIService.GetIsTraitImplemented")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/traits/{contract_address}/{contract_name}/{trait_contract_address}/{trait_contract_name}/{trait_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"contract_address"+"}", url.PathEscape(parameterValueToString(r.contractAddress, "contractAddress")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contract_name"+"}", url.PathEscape(parameterValueToString(r.contractName, "contractName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trait_contract_address"+"}", url.PathEscape(parameterValueToString(r.traitContractAddress, "traitContractAddress")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trait_contract_name"+"}", url.PathEscape(parameterValueToString(r.traitContractName, "traitContractName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trait_name"+"}", url.PathEscape(parameterValueToString(r.traitName, "traitName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tip", r.tip, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
